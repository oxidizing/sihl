{0 Sihl}

{%html:
<p align="center">
  <a href="https://github.com/oxidizing/sihl">
    <img style="display: block; margin: 0 auto;" src="https://github.com/oxidizing/sihl/blob/master/images/logo.png?raw=true" alt="Logo"/>
  </a>
</p>
%}

Sihl is a batteries-included web framework built on top of {{: https://github.com/rgrinberg/opium } opium}, {{: https://github.com/paurkedal/ocaml-caqti } caqti}, {{: https://erratique.ch/software/logs } logs} and {{: https://github.com/oxidizing/sihl/blob/master/dune-project } many more}. Thanks to the modular architecture, included batteries can be swapped easily. Statically typed functional programming with OCaml makes web development fun and safe.

{1 Getting Started}

{2 Installation}

Sihl is distributed through {{: https://opam.ocaml.org/doc/Install.html} opam}, so go ahead and install it.
The easiest way to get started is to use {{: https://github.com/tmattio/spin} Spin} to generate a Sihl app. Go ahead and install it.
With opam it can be installed easily with [opam install spin].

{2 App Generation}

Run [spin new https://github.com/oxidizing/spin-sihl.git app] where [app] is the directory where you want to create your app in.
After providing Spin with the answers you have to wait for the dependencies to be compiled. This takes a while the first time.

{%html: <p align="center">
  <a href="https://github.com/oxidizing/sihl">
    <img src="https://raw.githubusercontent.com/oxidizing/sihl/master/images/sihl-demo.svg" alt="Spin template for project generation.">
  </a>
</p>
%}

{2 Configuration}

One of the design goals of Sihl is safety. A Sihl app does not start if the required configurations are not present. You can get a list of required configurations with the command [make sihl config:list]. Note that the list of configurations depends on the services that are installed.

{3 Providing Configuration}

There are three ways to provide configurations:
- environment variables
- [.env] files
- programmatically using {!val:Sihl.Configuration.store}

[.env] files have to be placed in the project root directory. Sihl tries to find out where that is, in general the root is where you have your [.git] folder. You can override the project root with the environment variables [ROOT_PATH]. You can set the location of your [.env] file with the environment variable [ENV_FILES_PATH] if you want to move it away from the project root.

{3 Reading Configuration}

Use {!module:Sihl.Configuration} for reading configuration. You can also use it to programmatically store some configuration

Examples:

{[
let smtp_host = Sihl.Configuration.read_string "SMTP_HOST" in
]}

{2 Directory Structure}

TODO after making final changes

{1 Architecture Concepts}

As wisely stated in Laravel's {{:https://laravel.com/docs/8.x/lifecycle#introduction}documentation}:

"When using any tool in the "real world", you feel more confident if you understand how that tool works. Application development is no different. When you understand how your development tools function, you feel more comfortable and confident using them."

{2 Request Lifecycle}

In backend web development, everything starts with a HTTP request. Sihl uses {{:todo}Opium} and {{:todo}Rock} under the hood. Your job is it, to create a [Rock.Response.t] given a [Rock.Request.t].

This is done using a handler, which has the signature [val handler : Rock.Request.t -> Rock.Response.t Lwt.t]. In the handler you call your own code and Sihl services. A handler looks like this:
{[
let list req =
  let open Lwt.Syntax in
  let csrf = Sihl.Web.Csrf.find req in
  let notice = Sihl.Web.Flash.find_notice req in
  let alert = Sihl.Web.Flash.find_alert req in
  let* todos, _ = Todo.search 100 in
  Lwt.return @@ Opium.Response.of_html (Template.page csrf todos alert notice)
;;
]}

In order to wrap handlers and add functionality to them in a functional way, we need a function that takes a handler and returns a handler [val middleware : handler -> handler].

A request has following lifecycle:
{ul
{- {b HTTP Request}: The HTTP server receives a request}
{- {b Route}: The request either matches one of the routes or it doesn't }
{- {b Middleware in}: The request goes through a list of middlewares }
{- {b Handler}: The request reaches a handler and triggers service calls which yields in a response }
{- {b Middleware out}: The response goes through a list of middlewares }
{- {b HTTP Response}: The response is sent back }
}

In order to learn more about the request lifcycle, check out Opium's {{:todo}examples}.

{2 Service Container}

Many of Sihl's features are provided as services.

Services can have dependencies on each other. The {!module:Sihl.Database.Migration} service depends on the {!module:Sihl.Database} service, since running migrations requires a database connection.

To be precise, service {e implementations} can have dependencies. It is important to differentiate between service implementation and service contract. Nothing says, that {!module:Sihl.User} has to depend on {!module:Sihl.Database.Migration} since the user service might be implemented in-memory. Both provided implementations {!val:Sihl.User.Implementation.mariadb} and {!val:Sihl.User.Implementation.postgresql} depend on the migration service.

In the file [run.ml] you find a list of registered services. Sihl knows about their dependencies and starts them in the right order.

A [run.ml] setup when using PostgreSql could look like this:

{[
let services =
  [ Sihl.Cleaner.register cleaners
  ; Sihl.Database.Migration.(register ~migrations Implementation.postgresql)
  ; Sihl.Token.(register Implementation.postgresql)
  ; Sihl.Email_template.(register Implementation.postgresql)
  ; Sihl.User.(register Implementation.postgresql)
  ; Sihl.Session.(register Implementation.postgresql)
  ; Sihl.Token.(register Implementation.postgresql)
  ; Sihl.Queue.(register ~jobs Implementation.postgresql)
  ; Sihl.User.Password_reset.register ()
  ; Sihl.Email.(register Implementation.smtp)
  ; Sihl.Schedule.register ()
  ; Sihl.Web.register Web.Route.all
  ]
;;
]}

{2 Context}

In the directory [app/context] you have multiple {{:https://martinfowler.com/bliki/BoundedContext.html}contexts}. You can have one big context in the beginning and extract parts into separate contexts as you go. Sihl makes no assumptions about this directory and you are free to structure your code the way you want. Have your repos, services, models DTO's in here.

The crucial part is that your app containing all the business rules is in [app/context]. Sihl helps you to make that app accessible through the internet, but your app should be more or less portable. You should be able to take [app/context] and use it with some other framework. Not that you should of course, this is just a useful mental model :).

{1 The Basics}

This section guides you through the basics to build simple web apps with Sihl.

{2 Routing}

The routes are the entry points to your app through HTTP. They define in a declrative what can be done with it, either by a human user or by another application.

Routes can be created with {!module:Sihl.Web.Http} like:

{[
let list_todos = Sihl.Web.Http.get "/" Handler.list
let add_todos = Sihl.Web.Http.post "/add" Handler.add
let do_todos = Sihl.Web.Http.post "/do" Handler.do_
]}

A route takes a path and a handler.

The routes live in the the root directory [/route/api.ml] or [/route/site.ml]. A list of routes can be mounted under a path (called scope) with a middleware stack. The site routes for instance are mounted like:

{[
let site_router =
  Sihl.Web.Http.router
    ~middlewares:(Middleware.site ())
    ~scope:"/"
    [ list_todos; add_todos; do_todos ]
;;
]}

This creates a {!type:Sihl_contract.Http.router} that can be registered with the HTTP service in [run.ml].

{2 Middleware}

Provided Sihl middlewares live in {!module:Sihl.Web} like {!module:Sihl.Web.Csrf} or {!module:Sihl.Web.Session}. Check out their documentation below to learn about the usage.

By default Sihl creates two middleware stacks:

{[
let site () =
  [ Sihl.Web.Id.middleware
  ; Sihl.Web.Error.middleware ()
  ; Opium.Middleware.logger
  ; Opium.Middleware.content_length
  ; Opium.Middleware.etag
  ; Sihl.Web.Static.middleware ()
  ; Sihl.Web.Session.middleware ()
  ; Sihl.Web.Form.middleware
  ; Sihl.Web.Csrf.middleware ()
  ; Sihl.Web.Flash.middleware ()
  ; Sihl.Web.User.session_middleware ()
  ]
;;

let json_api () =
  [ Sihl.Web.Id.middleware
  ; Opium.Middleware.logger
  ; Sihl.Web.Error.middleware ()
  ; Sihl.Web.Json.middleware
  ; Sihl.Web.Bearer_token.middleware
  ; Sihl.Web.User.token_middleware ()
  ]
;;
]}

Have a look at the {{:todo}middlewares} that ship with Opium.

- {!module:Sihl.Web.Authentication}
- {!module:Sihl.Web.Authorization}
- {!module:Sihl.Web.Bearer_token}
- {!module:Sihl.Web.Csrf}
- {!module:Sihl.Web.Error}
- {!module:Sihl.Web.Flash}
- {!module:Sihl.Web.Form}
- {!module:Sihl.Web.Id}
- {!module:Sihl.Web.Json}
- {!module:Sihl.Web.Session}
- {!module:Sihl.Web.Static}
- {!module:Sihl.Web.User}

{2 CSRF Protection}

TODO:
- what is it?
- middleware
- fetch token
- tyxml template

{2 Requests}

TODO:
- it contains body, header, method
- show opium samples
- refer to opium

{2 Responses}

TODO:
- it contains body, header, method
- show opium samples
- refer to opium

{2 Session}

TODO:
- session service
- middleware

{2 Error Handling}

- custom error page
- email on error

{2 Logging}

{1 Database}

The {!Sihl.Database} module provides functions for querying the database, running database schema migrations and it deals with connection pooling.

{2 Query Interface}

{2 Migrations}

{2 Seeding}

{1 Testing}

{2 Cleaning}

{2 System Tests}

{1 Digging Deeper}

{2 Randomness}

{2 Scheduling}
